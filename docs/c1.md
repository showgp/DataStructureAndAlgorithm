# 第一章: 概述

本书的目标是让读者学习一系列重要且实用的算法(适合通过计算机实现的解决问题的办法). 算法必然和数据结构紧密相连. 数据结构是使得数据能够被算法高效处理的一种数据组织形式(也可以说数据和数据之间的关系组合成为数据结构). 

## 1.0 导学

本章的主要目的是介绍之后学习数据结构和算法时候用到的基本工具, 包括:

- 基本编程模型: 基于 Java 的一个子集, 并包含自定义的 I/O 库.

- 抽象数据类型(ADT): 目的是进行模块化开发.

- 三种基本的 ADT(bag, stack, queue), 以及它们的实现.

    基于定长数组/可扩容数组/链表的实现, 这些内容将作为后续的算法和数据结构实现的基础.

- 算法性能分析: 

- 总结: 使用并查集(union-find) ADT 解决连通性(Connectivity)问题.

## 1.1 基本语言工具

这里采用 C#, 实际和 Java 在语法上差距不大.

需要熟悉的是:

- 基本数据类型

- 数组: 比如如下的简单写法

    ```cs
    char[] a = new char[3];
    a[0] = 'a';
    System.Console.WriteLine(a[0]);
    ```

- 字符串

- I/O

- 制作 library: 库的作用是以 API 隔离实现, 最为关键的是它提供了一层抽象, 让我们可以将视角放在当前的关注点上.

- 单元测试

其他的工具还有随书的标准库, 小型的绘图库等.

需要看的还有就是练习题和 Q/A 部分.

## 1.2 数据抽象

1.2 主要介绍的是 JAVA 中的数据抽象，对象/类等机制。

## 1.3 Bags/Queue/Stack

这三个作为其他数据结构的基础, 介绍它们主要是为了:

- 了解集合的数据结构对于操作的影响

- 介绍泛型的实现

- 了解链式存储的重要作用

针对每种结构, 全书都根据先介绍它们的 API 和客户代码, 再介绍它们的内部实现这样的套路来的.

### 1.3.1 三种结构的 API

Bag: `public class Bag<Item> implements Iterable<Item>`

- `Bag()`: create an empty bag

- `void add(Item item)`: add an item

- `boolean isEmpty()`: is the bag empty?

- `int size()`: number of items in the bag

Queue: `public class Queue<Item> implements Iterable<Item>`

- `Queue()`: create an empty queue

- `void enqueue(Item item)`: add an item

- `Item dequeue()`: remove the least recently added item

- `boolean isEmpty()`: is the queue empty?

- `int size()`: number of items in the queue

Stack: `public class Stack<Item> implements Iterable<Item>`

- `Stack()`: create an empty stack

- `void push(Item item)`: add an item

- `Item pop()`: remove the most recently added item 

- `boolean isEmpty()`: is the stack empty?

- `int size()`: number of items in the stack

由于泛型参数需要是引用类型的, 如果使用原子类型, 就需要进行装箱和拆箱操作, 关于装箱/拆箱详见[这个链接](https://blog.csdn.net/qiaoquan3/article/details/51439726).

另外许多的需求都要求能够对集合进行遍历操作, 通过实现 `Iterable` 接口, 就可以在不知道集合内部结构的情况下对集合进行遍历(比如使用 `foreach`).

### 1.3.2 Bag

Bag 是一种只能进行添加和遍历的容器, 且它的遍历是无序的(类似 Set). 目的是提供给客户端一个收集元素的工具.

一个典型的 Bag 使用者代码如下所示:

```java
public class Stats
{
   public static void main(String[] args)
   {    
        // 如下计算 N 个数的平均值和标准差

        Bag<Double> numbers = new Bag<Double>();
        while (!StdIn.isEmpty()) numbers.add(StdIn.readDouble());
        int N = numbers.size();
        double sum = 0.0;
        for (double x : numbers)
        sum += x;
        double mean = sum/N;
        sum = 0.0;
        for (double x : numbers)
        sum += (x - mean)*(x - mean); 
        double std = Math.sqrt(sum/(N-1));
        StdOut.printf("Mean: %.2f\n", mean);    // 输出平均值
        StdOut.printf("Std dev: %.2f\n", std);  // 输出标准差
    }
}
```

### 1.3.3 Queue

队列是一种先进先出(FIFO)的结构. 使用它的主要目的是收集元素, 并保持他们在遍历过程中(或出队时候)的先后顺序.

一个段典型的客户代码如下所示:

```java
public static int[] readInts(String name) {
    In in = new In(name);
    Queue<Integer> q = new Queue<Integer>(); 
    while (!in.isEmpty()) q.enqueue(in.readInt());
    int N = q.size();
    int[] a = new int[N];
    for (int i = 0; i < N; i++) a[i] = q.dequeue(); 
    return a;
}
```

### 1.3.4 Stack

Stack 是一种 LIFO 类型的数据结构, 即后进先出的结构. 在遍历时, 所有元素的顺序和它们入栈时候的顺序相反.

一个典型的客户代码如下所示, 它将某个序列进行逆序输出:

```java
public class Reverse {
    public static void main(String[] args)
    {
        Stack<Integer> stack;
        stack = new Stack<Integer>(); 
        while (!StdIn.isEmpty()) stack.push(StdIn.readInt());
        for (int i : stack) StdOut.println(i);
    }
}
```

### 数学表达式求值

数学表达式求值的时候，可以先从中缀转后缀，然后再从后缀表达式求值.

如果是按顺序扫描整个表达式计算的情况, 则可以先忽略左括号, 把操作符和操作数分别用栈存放, 当遇到右括号时, 从操作符栈取一个操作符, 然后出栈两个操作数, 计算结果后存入操作数栈.

## 1.4 这些集合的实现

基于学习的目的, 首先介绍这三种数据类型的最简单实现, 然后逐步进行优化.

> 在 API 的实现过程中, 一个要点就是选择数据的表示方式.

### 1.4.1 定长字符串 Stack 的实现

定长字符串 Stack 的数据表现形式: 使用一个定长数组表示.

API 如下所示:

```java
interface FixedCapacityStackOfStrings {
    int void push(String item);

    String pop();

    boolean isEmpty();

    int size();
}
```

一个典型的用户程序(如果再加工一下, 就可以成为一个单元测试程序了):

```java
public static void main(String[] args)
{
    FixedCapacityStackOfStrings s;
    s = new FixedCapacityStackOfStrings(100); 
    while (!StdIn.isEmpty()) {
        String item = StdIn.readString(); 
        if (!item.equals("-")) s.push(item);
        else if (!s.isEmpty()) StdOut.print(s.pop() + " ");
    }
    StdOut.println("(" + s.size() + " left on stack)");
}
```

通过上面的例子可以看到, 非泛型实现的 Stack 使用上非常局限. 故实现了一个泛型的定长 Stack.

### 1.4.2 数组的扩容

由于在 Java 或 C# 等语言中创建的数组是定长的, 进而造成如果使用定长数组来实现 Stack, 就必须在创建时指定大小, 这显然是非常死板的.

故在 push 或 pop 的实现时, 根据当前数组是否满, 或者当前容量未能超过数组最大容量的 1/4, 将数组进行大小进行调整:

```java
private void resize(int maxSize) {
    Item[] temp = (Item[]) new Object[max];
    for (int i = 0; i < N; i++)
        temp[i] = a[i];
    a = temp;
}
```

### 1.4.3 迭代器

使用迭代器的目的是让客户代码可以在不知道集合内部具体数据类型的情况下, 对集合进行遍历.

典型的客户代码如下所示, 使用 `foreach` 进行遍历:

```java
Stack<String> collection = new Stack<String>();
for (String s : collection) StdOut.println(s);
```

上述代码等价于获取到集合的 iterator 后再进行 while 操作:

```java
Iterator<String> i = collection.iterator(); 
while (i.hasNext()) {
    String s = i.next();
    StdOut.println(s);
}
```

可以看到, 迭代器的主要方法就两个: 

- `hasNext`

- `next`

实现了一个 C# 版本的逆序迭代器, 实现上说还是非常简单的.

### 1.4.4 链表

链表的定义可以使用递归描述, 它要么是空, 要么是一个节点, 这个节点包含数据域和指向链表节点的指针域.

链表插入和删除操作:

- 从头部添加/删除

- 从尾部添加/删除

链表的遍历操作: 跟随 next 指针一路遍历直至 next == null.

有了上述前提, 就可以实现以链式存储结构表示的栈逻辑结构了.

### 1.4.5 队列

由于队列是先入先出结构, 使用链表来表示非常合适. 

主要操作如下:

- enqueue: 从队尾入队

- dequeue: 从队头出队

一段典型的队列客户代码如下所示:

```java
// Create a queue and enqueue/dequeue strings
public static void main(String[] args) { 
    Queue<String> q = new Queue<String>();
    while (!StdIn.isEmpty()) {
        String item = StdIn.readString(); 
        if (!item.equals("-")) q.enqueue(item);
        else if (!q.isEmpty()) StdOut.print(q.dequeue() + " ");
    }
    StdOut.println("(" + q.size() + " left on queue)"); 
}
```

简单队列在实现的时候仍然采用单链表, 并记录队首, 队尾, 队列长度等信息.

### 1.4.6 队列和栈的实现: 基于单链表

1. 单链表的 TDD 实现: 头插完成. 准备尾插.

1. 基于单链表的队列/栈/bag实现: 采用 TDD.

1. 几种基本数据结构的迭代接口/迭代器实现: 在迭代器输出值的过程中, 需要遵循如下顺序:

- 队列 FIFO

- 栈: LIFO

- bag: LIFO

上述几种数据结构和它上面的操作必须熟练, 因为他们是后续学习的基础:

1. 在后续学习过程中, 需要基于上述基本数据结构来实现更高级的其他数据结构.
1. 在基本数据结构实现过程中, 可以认识到数据结构上面的算法是如何实现的, 并且是如何保证性能的.
1. 我们着眼点是在 ADT 上, 这些 ADT 支持针对集合的更为复杂的操作.

### 1.4.7 总结

当前我们可以使用两种**存储结构**来表示集合了:

- 顺序存储: 数组, 支持随机存取, 插入删除开销较大, 但需要在初始化时指定空间大小.

- 链式存储: 链表, 支持快速插入删除, 但不支持随机存取.

其他的存储结构有待探索.

但逻辑结构目前还只学了一种: 线性结构, 不过后续还会接触到树和图. 关注的重点是在数据结构特性上, 另外就是数据结构的组合使用上.

复杂的数据结构可以通过简单的数据结构进行组合构成, 将关注点放到抽象接口上, 可以帮助减少数据结构在实现和理解上的复杂性.

另外在书中使用如下流程(套路)来介绍一个数据结构和在它上面实现的算法:

1. 定义 API
1. 实现客户代码(或单元测试 TDD)
1. 描述可以实现这个 API 的数据结构的 ADT.
1. 描述算法, 这些算法即 API 所需的方法实现描述.
1. 分析算法的性能特征(时间/空间).

## 1.5 算法分析

在实现算法时, 主要关心的是算法的时间开销和内存开销, 即时间和空间两个方面的考虑.

在分析时, 使用数学分析方法来定义一个精确的模型, 根据实际的情况来修正这个模型, 

根据现实世界中的模型构建, 步骤可以描述为:

1. 观察自然界中的某个特征, 通常使用一些精确的测量方法, 比如用 StopWatch 来看测量代码的执行时间.

1. 通过这些观察, 生成一个假设模型.

1. 通过模型预言这个特征未来的变化规律.

1. 通过更多的观察和测量来验证假设, 然后不断修正假设模型

1. 重复这样的过程, 直到假设模型的预测和现实数据吻合.

### 1.5.1 特征观察

使用如下例子程序来进行:

```cs
//  分析时, 主要测试这段代码的执行时间:
public static int Count(int[] a) {
    int N = a.Length;
    int cnt = 0;
    for (int i = 0; i < N; i++)
        for (int j = i + 1; j < N; j++)
            for (int k = j + 1; k < N; k++)
                if (a[i] + a[j] + a[k] == 0) cnt++;
    return cnt;
}

// 生成随机数组, 通过命令行参数获取输入的规模(有多少个数字)
public static int[] GetRandomArray(string[] args) {
    int count = int.Parse(args[0]);
    int[] a = new int[count];
    for (int i = 0; i < count; i++)
        a[i] = new Random().Next(-1000000, 1000000);
    return a;
}
```

### 实验数据分析

1. 问题规模:

    需要观察的是: 随问题规模增长, 运行时间是如何增长的?

将例子修改为内部成倍增长的, 这样可以对比运行时间.

可以进行的第一个假设: 所有电脑上的运行时间差异都是线性的, 即对比起来和电脑性能呈线性关系, 性能是两倍, 则执行时间差不多也就是二分之一.

下一个问题是: 根据问题规模 n, 怎么建立一个函数 `T(n)` 来求运行时间?

针对这个问题, 我们可以将数据绘制(plot)到二维坐标系下, 横轴表示问题规模, 纵轴表示时间.

有两种绘制方式

- 一种是原样绘制, 即运行时间 `T(n)` 为纵轴, n 为横轴 

- 另外一种是对问题规模和时间均取 10 为底的对数, 即 lg(T(n)) 作为纵轴,  lg(n) 作为横轴.

根据 lg-lg 绘制的图形, 可以发现数据呈现一条直线, 且斜率(slope)为 3. 底部有一个常数高度. 故 lg(T(n)) 可以计算为: `lg(T(n)) = 3 * lg(n) + lga`.

把上面的等式转换得到: `T(n) = an³`

这样的话, 可以在某台计算机上先观察 T(8000) = 51.1, 这样再根据等式即可计算出 a 的值. 然后就可以预测 T(16000) 等的值了.

这样的观察是基于科学实验的方法的, 根据前人的研究, 演化出下面的数学模型.(验证了实验方法的准确性是很高的.)

### 数学模型

D.E.Knuth 很早之前就指出, 抛开预测运行时间周边的复杂因素, 我们实际上可以原则上建立一个数学模型来描述任意程序的运行时间. 而程序的总运行时间主要由如下两个因素决定:

1. 每条语句执行的开销
1. 每条语句执行的频率

前者是由计算机的不同, 以及编译器和操作系统等外部条件来决定的, 而后者是独立于计算机的, 只由程序(或算法)本身决定.

主要的难度在于如何确定语句的执行频率: 有些语句可以直接看出来, 有些语句的执行需要依赖外部输入的状态决定, 这个时候就需要使用概率分析的方法来计算执行频率.

波浪线记号方法: 使用 `~` 来表示忽略表达式中低阶组成. 

`~f(n)`: 表示任意函数 f, f 函数的性质是随着 n 的增长, `f(n)/~f(n)` 随之趋近于 1.

`g(n)~f(n)`: 表示 g(n)/f(n) 的结果随 n 的增长不断趋近于 1. 称 `g(n)` 是 `f(n)` 的渐进增长.

比如之前例子程序的 if 语句总共执行次数为: `N³/6 - N²/2 + N/3`, 则它的波浪线近似是: `N³/6`, 因为 `(N³/6 - N²/2 + N/3) / N³/6` 随 N 的增长无线趋近于 1.

这些数学工具有了, 下面来看运行时间估计.

渐进增长函数和波浪线记号函数为线性关系, 即 `g(n)~af(n)`. 需要验证 `T(N)~ag(n)`.

开销模型(Cost Model): 定义解决问题算法的基本操作.

比如在例子程序中, 将 cost model 定义为数组访问的次数(基本操作) if 语句的 ~f(n)=N³/6, 则例子使用了 ~N³/2 次的数组访问操作.

在书中都是使用一个算法的 Order Of Growth(OoG) 来看算法效率. 一般而言, 线性, 对数, 线性对数是三个性能较好的. 所以在基本问题的算法上, 一般都希望开发这三种 OoG 类型.

而学习算法分析的最终目的也是帮助我们开发更加高效的算法.

### 开发一个三数和的高效算法

之前示例程序中 ThreeSum 的 OoG 为 N³, 下面就来看如何开发一个更高效的算法.

根据书上的结论, 归并排序的 OoG 是线性的, 二分查找的 OoG 是对数, 有方法可以借助二者实现 ThreeSum.

先看两个数相加:

    两个数相加的高效算法可以是这样: 先把数组进行排序(排序的大小顺序和结果无关), 排序后使用二分查找 -a[i] 的值, 找到下标 j, 如果 j > i, 表示找到一个合适的值. (由于是从 0 到 n 每个数都执行一次二分查找, 指定 j 大于 i 以避免重复记录之前的 pair).

已实现 FastTwoSum.

快速 ThreeSum 的处理:

先假设数组中的数是互异的, 找三个数相加等于 0 的个数. 

给定一个数对 a[i] 和 a[j], 如果它们属于满足条件的元组, 则意味着此时需要去找有没有一个数的值为 -(a[i] + a[j]), 如果有, 则构成三个数和为 0 的元组.

实现如下所示:

```cs
public class FastThreeSum {
    public static UInt64 Count(int[] a) {
        // 排序
        Array.Sort(a);
        UInt64 count = 0;
        for (int i = 0; i < a.Length; ++i) {
            for (int j = i + 1; j < a.Length; ++j)
                if (Array.BinarySearch(a, -(a[i] + a[j])) > j) count++;
        }
        return count;
    }
}
```

频率最大的还是内部的二分查找, 查找一共执行了 N * (N - 1) / 2 次(等差数列求和). 而二分查找的 OoG 是 logN, 故这个算法的 OoG 是 N²logN.

上述两个算法都是属于蛮力算法的范畴.

### 倍率实验

下面介绍一个适用于分析任意问题的预期性能和 OoG 的简单高效的方法:

1. 开发一个数据生成器用来生成实验数据(比如上面生成随机数数组)

1. 运行如下的倍率实验代码, 代码的作用是输出前一轮和当前运行时间的比值

1. 一直运行, 直到倍率达到一个限定值 `2的b次方` 的时候停止. 当然有的问题可能不会触发停止, 但大多数问题都会触发.

根据倍率实验可以得到如下结论:

1. 问题的 OoG 约为 `N的b次方`.

1. 运行时间可以使用如下方程表示: T = 最后一次运行时间长度 * 2的b次方 ?

倍率实验是一个有效的工具, 建议如果性能需求很高的情况下, 都运行一下倍率实验确定 OoG.

有了 OoG 之后, 我们可以根据它来:

1. 估计大型问题的解决时间, 针对大型输入, 看这个算法是否能在合理的时间长度内解决.

1. 估计这个问题是否可以通过更好性能的机器来处理, 如果提升机器性能对问题解决时间帮助不大, 则需要提升的是算法而非机器.

TODO: 需要开发自己的 DoublingRatio 程序来看看执行时间, 不过貌似 iOS 单元测试中的性能测试就属于这个范畴.

### 提醒

在分析程序性能的时候, 有许多干扰因素.

1. **大常数**: 有些时候我们会把 OoG 中的低阶常数忽略, 但如果某个常数达到 10的若干次方, 但又相对低阶, 此时这样的常数也会成为一种干扰因素.

1. **非显式的内循环**: 有些内部循环可能不易识别. 另外有一些问题的外部代码可能会和最内层循环执行开销接近, 此时就需要对开销模型进行仔细定义.

1. **指令执行时间**: 指令执行时间不变的假设有可能不准确, 因为现代计算机都有高速缓存机制.

1. **系统考虑**: 由于计算机系统中有许多程序在同时执行, 可重现的假设有可能不准确, 因为程序间各自存在资源竞争.

1. **问题解法多样**: 有时同一问题的多个解法在不同的场合(输入等)下可能执行速度差异很大.

1. **问题的解法依赖输入**: 有时同一问题的同一解法在不同输入下的性能差异会很大.

1. **问题的参数众多**: 一个问题的解法输入参数可能不止一个.

针对上述因素, 可能目前 OoG 的假设会被推翻, 但针对它的实践用途而言, 不会受太大影响. 精确的模型还是交给专家去研究.

### 算法对问题输入的依赖

最大的一个问题是某些算法对输入的依赖会非常高. 这样的话, 在分析时就不能再把输入忽略了.

1. **输入模型**: 当然我们可以把算法的输入在合法的范围内再进行限定, 但这样肯定会不切实际.

1. **最坏性能保证**: 

1. **随机输入**: 

## 1.6 动态连通性问题

下面来看一个基本问题的解法: 动态连通性问题的算法.

首先, 这个例子的目的是说明如下内容:

- 通过一个好的算法去真正地解决实际问题, 而非仅仅说明算法.

- 高效的算法和低效的算法实际上实现难易程度上类似.

- 算法的性能分析是非常有趣且有挑战性的.

- 使用科学的方法在同一问题的不同解法间做出抉择

- 通过渐进式地改进过程来实现一个高效的算法.

### 1 动态连通性问题

数据结构总是会对算法实现的效率有直接的影响. 所以算法和数据结构的设计和实现总是关联在一起进行的. 由于我们使用的是简化的 API, 在其中的节点或 Component 都是通过 int 编号表示的.

## 普林斯顿的动态连通性问题课程

在动态连通性问题的章节中, 主要学习两个算法, 一个是快速合并, 一个是快速查找. 以及这些算法的实现和改进.

要开发一个有用的算法, 步骤大体如下:

1. 对问题进行建模, 找出解决这个问题大致需要什么样的操作, 即定义解法的 API.

1. 寻找一些解决这个问题的算法.

1. 算法是否可用, 是否满足空间和时间的需求, 如果不满足, 进行迭代, 直到解法满足需求.

问题的建模就是: 有一组 N 个对象, 对象间可以通过一个 "连接" 命令将它们连接起来. 这个命令就是 union 命令. 还有一个命令是 isConnected 命令, 找出两个对象之间是否连接.

针对"两个点是连接的"这一表述, 有如下假设:

1. 连接关系是对称的(Symmetric)

1. 连接关系是可传递的(Transitive)

1. 连接关系是直观的(Reflexive)

有了上述假设后, 连接的集合就分裂为许多子集, 一个所有点都连通的子集就是一个连通分量(Component).

算法中通过维护所有的连通分量来实现高效的 find 和 union.

在实际解决的时候, 仍然是先定义 API, 然后定义客户端, 然后是定义数据结构, 然后再在数据结构上实现算法. 最后会对不同算法进行分析.

动态连通问题的一些典型场景如下:

- 网络(Networks): 网络中的节点表示位于网络中的计算机, 节点间的关系就表示网络中的连接情况. 通过解决这样的动态连通问题, 我们就可以决定是否需要在两台计算机之间创建一条网络通信线路(没有连通的情况), 或只需要利用之前的线路即可实现两台计算机之间的通信. 用电器之间的电路连接, 人类社会中的社交关系等都属于这样的情况. 我们可能处理数百万的节点或连接情况.

- 变量名称相等关系: 在任意的开发环境中, 都可能声明一个变量和另外一个变量相等(引用同一片内存区域), 当经过若干次的相等关系传递, 系统需要确定某两个变量是否表示相同的内存(相等关系).

- 数学上的集合: 某个节点包含在某个数学意义上的集合中, 当我们处理两个节点 p, q 时, 我们可以通过动态连通问题的解法来判断它们是否是在同一个连通集合, 如果不在同一集合, 我们就可以将两个集合合并.

我们设计一个构造输入的流程是这样的: 输入所有点的数量, 然后输入一系列的两点连接关系.

```cs
10
4 3
5 2
//...
```

### Quick Find

首先介绍的算法是快速查找, 使用 int 数组作为我们求解问题的数据结构.

首先给定 10 个点,它们分别属于 10 个不同的连通分量.

数据结构的初始值:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 2 3 4 5 6 7 8 9

(约定把后一个的连同分量编号赋值给前一个).

执行 `Union(4, 3)`操作: (此时 3 和 4 都属于下标为 3 的连通分量内, 它们已经是连通的了)

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 2 3 3 5 6 7 8 9

执行 `Union(3, 8)`操作: 由于之前 3 和 4 是连通分量 3 中的, 此时需要把 3 和 4 都修改为 8 的连同分量编号 8

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 2 8 8 5 6 7 8 9

执行 `Union(6, 5)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 2 8 8 5 5 7 8 9

执行 `Union(9, 4)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 2 8 8 5 5 7 8 8

执行 `Union(2, 1)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 1 8 8 5 5 7 8 8

执行 `Union(8, 9)`操作: 由于 8 和 9 之前就已经是在同一个连同分量中, 故无需改变

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 1 8 8 5 5 7 8 8

执行 `Union(5, 0)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 1 8 8 0 0 7 8 8

执行 `Union(7, 2)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 0 1 1 8 8 0 0 1 8 8

执行 `Union(6, 1)`操作:

下标: 0 1 2 3 4 5 6 7 8 9
数据: 1 1 1 8 8 1 1 1 8 8

上述的过程表达了一个很直观的操作流程: 数组的下标表示点, 数组中的值表示连通分量编号.

1. 先找出后一个点的连通分量编号(下标的值)

1. 如果前一个点(下标)的连通分量编号(下标对应的值)和后一个不同, 则进行下一步, 否则两个是在同一个连通分量中, 无需改变.

1. 找出前一个点(下标)的连同分量编号(下标对应的值)相同的所有点(下标), 将这些点(下标)的连通分量编号(下标对应的值)赋值为后一个点的值即可.

如下是实现过程:

1. 基于数组数据结构, 先处理实现类的构造方法:

    ```cs
    public class QuickFindUF : IUnionFind {
        private int[] id;

        public QuickFindUF(int numberOfItems) {
            // 构造数据数组, 初始状态下所有的点都位于不同的连通分量中
            id = new int[numberOfItems];
            for (int i = 0; i < numberOfItems; ++i) {
                id[i] = i;
            }
        }
    }
    ```

1. 实现 `IsConnected` 方法: 只需要判断两个点(下标)对应的值是否相同

    ```cs
    public bool IsConnected(int p, int q) => id[p] == id[q];
    ```

1. 实现 `Union` 方法: 只需要把所有等于前一个点连通分量编号的所有值修改为后一个的即可.

    ```cs
    public void Union(int p, int q) {
        // 1 找出 p 的值, q 的值
        var pID = id[p];
        var qID = id[q];
        // 2 将数组中所有等于 pID 的值修改为 qID
        for (int i = 0; i < id.Length; ++i)
            if (id[i] == pID) id[i] = qID;
    }
    ```

这个实现的开销模型就是在 Union 中的数组访问次数. 几个方法中:

- 构造方法: N

- Union: N

- Find: 1

最坏的情况是, 如果对 N 个点执行 N 次 Union 操作, 则所有操作次数是 N².(比如0-4个点, 0-1, 1-2, 2-3, 3-4, 4-0)

我们在开发算法的时候, 会尽力去避免写出 N² 复杂度的算法. 这样的算法执行性能不会随计算机性能提升有所提升. 因此, 我们需要开发一个 QuickUnion 方法.

### QuickUnion

待续.

## 本节小结

我们关注的算法都是经过了几十年的研究和发展的, 在未来也会继续发挥它们的重要作用. 本书的章节划分如下:

1. C1 Fundamentals: 介绍用于算法实现/分析/比较的基本原则和基本方法.

1. C2 Sorting: 深入介绍插入排序, 选择排序, 希尔排序, 快速排序, 归并排序, 堆排序. 另外介绍一些相关问题(优先级队列, 选择, 合并)的算法. (排序的另一个目的是为查找服务)

1. C3 Searching: 介绍有关查找的基础/高级方法, 包括二叉查找树, 平衡搜索树, 哈希.

1. C4 Graphs: 图是许多重要问题的主要模型. 这章介绍图的广度优先/深度优先搜索, 连通性问题, 最小生成树, 最短路径等问题.

1. C5 Strings: 字符串是现代计算机程序的重要数据类型. 字符串即字符序列, 本章介绍一些字符序列的处理算法, 包括字符序列的排序和查找, 子串搜索, 正则表达式匹配, 数据压缩算法.

1. C6 Context: 将本书介绍的方法应用到相关的上下文环境中, 例如科学计算, 运筹学, 计算理论. 我们进而去探索事件驱动的模拟, B树等高级话题.

算法和数据结构紧密结合, 还需要学习一些数据结构的性质特点. 且要有这样的概念: 一个算法可以使用任何语言在任何平台上都能实现的.