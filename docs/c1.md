# 第一章: 概述

本书的目标是让读者学习一系列重要且实用的算法(适合通过计算机实现的解决问题的办法). 算法必然和数据结构紧密相连. 数据结构是使得数据能够被算法高效处理的一种数据组织形式(也可以说数据和数据之间的关系组合成为数据结构). 

## 1.0 导学

本章的主要目的是介绍之后学习数据结构和算法时候用到的基本工具, 包括:

- 基本编程模型: 基于 Java 的一个子集, 并包含自定义的 I/O 库.

- 抽象数据类型(ADT): 目的是进行模块化开发.

- 三种基本的 ADT(bag, stack, queue), 以及它们的实现.

    基于定长数组/可扩容数组/链表的实现, 这些内容将作为后续的算法和数据结构实现的基础.

- 算法性能分析: 

- 总结: 使用并查集(union-find) ADT 解决连通性(Connectivity)问题.

## 1.1 基本语言工具

这里采用 C#, 实际和 Java 在语法上差距不大.

需要熟悉的是:

- 基本数据类型

- 数组: 比如如下的简单写法

    ```cs
    char[] a = new char[3];
    a[0] = 'a';
    System.Console.WriteLine(a[0]);
    ```

- 字符串

- I/O

- 制作 library: 库的作用是以 API 隔离实现, 最为关键的是它提供了一层抽象, 让我们可以将视角放在当前的关注点上.

- 单元测试

其他的工具还有随书的标准库, 小型的绘图库等.

需要看的还有就是练习题和 Q/A 部分.

## 1.2 数据抽象

1.2 主要介绍的是 JAVA 中的数据抽象，对象/类等机制。

## 1.3 Bags/Queue/Stack

这三个作为其他数据结构的基础, 介绍它们主要是为了:

- 了解集合的数据结构对于操作的影响

- 介绍泛型的实现

- 了解链式存储的重要作用

针对每种结构, 全书都根据先介绍它们的 API 和客户代码, 再介绍它们的内部实现这样的套路来的.

### 1.3.1 三种结构的 API

Bag: `public class Bag<Item> implements Iterable<Item>`

- `Bag()`: create an empty bag

- `void add(Item item)`: add an item

- `boolean isEmpty()`: is the bag empty?

- `int size()`: number of items in the bag

Queue: `public class Queue<Item> implements Iterable<Item>`

- `Queue()`: create an empty queue

- `void enqueue(Item item)`: add an item

- `Item dequeue()`: remove the least recently added item

- `boolean isEmpty()`: is the queue empty?

- `int size()`: number of items in the queue

Stack: `public class Stack<Item> implements Iterable<Item>`

- `Stack()`: create an empty stack

- `void push(Item item)`: add an item

- `Item pop()`: remove the most recently added item 

- `boolean isEmpty()`: is the stack empty?

- `int size()`: number of items in the stack

由于泛型参数需要是引用类型的, 如果使用原子类型, 就需要进行装箱和拆箱操作, 关于装箱/拆箱详见[这个链接](https://blog.csdn.net/qiaoquan3/article/details/51439726).

另外许多的需求都要求能够对集合进行遍历操作, 通过实现 `Iterable` 接口, 就可以在不知道集合内部结构的情况下对集合进行遍历(比如使用 `foreach`).

### 1.3.2 Bag

Bag 是一种只能进行添加和遍历的容器, 且它的遍历是无序的(类似 Set). 目的是提供给客户端一个收集元素的工具.

一个典型的 Bag 使用者代码如下所示:

```java
public class Stats
{
   public static void main(String[] args)
   {    
        // 如下计算 N 个数的平均值和标准差

        Bag<Double> numbers = new Bag<Double>();
        while (!StdIn.isEmpty()) numbers.add(StdIn.readDouble());
        int N = numbers.size();
        double sum = 0.0;
        for (double x : numbers)
        sum += x;
        double mean = sum/N;
        sum = 0.0;
        for (double x : numbers)
        sum += (x - mean)*(x - mean); 
        double std = Math.sqrt(sum/(N-1));
        StdOut.printf("Mean: %.2f\n", mean);    // 输出平均值
        StdOut.printf("Std dev: %.2f\n", std);  // 输出标准差
    }
}
```

### 1.3.3 Queue

队列是一种先进先出(FIFO)的结构. 使用它的主要目的是收集元素, 并保持他们在遍历过程中(或出队时候)的先后顺序.

一个段典型的客户代码如下所示:

```java
public static int[] readInts(String name) {
    In in = new In(name);
    Queue<Integer> q = new Queue<Integer>(); 
    while (!in.isEmpty()) q.enqueue(in.readInt());
    int N = q.size();
    int[] a = new int[N];
    for (int i = 0; i < N; i++) a[i] = q.dequeue(); 
    return a;
}
```

### 1.3.4 Stack

Stack 是一种 LIFO 类型的数据结构, 即后进先出的结构. 在遍历时, 所有元素的顺序和它们入栈时候的顺序相反.

一个典型的客户代码如下所示, 它将某个序列进行逆序输出:

```java
public class Reverse {
    public static void main(String[] args)
    {
        Stack<Integer> stack;
        stack = new Stack<Integer>(); 
        while (!StdIn.isEmpty()) stack.push(StdIn.readInt());
        for (int i : stack) StdOut.println(i);
    }
}
```

待续(至140页), 准备看利用栈来实现数学表达式求值.

### 数学表达式求值

数学表达式求值的时候，可以先从中缀转后缀，然后再从后缀表达式求值.

如果是按顺序扫描整个表达式计算的情况, 则可以先忽略左括号, 把操作符和操作数分别用栈存放, 当遇到右括号时, 从操作符栈取一个操作符, 然后出栈两个操作数, 计算结果后存入操作数栈.

## 1.4 这些集合的实现

基于学习的目的, 首先介绍这三种数据类型的最简单实现, 然后逐步进行优化.

> 在 API 的实现过程中, 一个要点就是选择数据的表示方式.

### 1.4.1 定长字符串 Stack 的实现

定长字符串 Stack 的数据表现形式: 使用一个定长数组表示.

API 如下所示:

```java
interface FixedCapacityStackOfStrings {
    int void push(String item);

    String pop();

    boolean isEmpty();

    int size();
}
```

一个典型的用户程序(如果再加工一下, 就可以成为一个单元测试程序了):

```java
public static void main(String[] args)
{
    FixedCapacityStackOfStrings s;
    s = new FixedCapacityStackOfStrings(100); 
    while (!StdIn.isEmpty()) {
        String item = StdIn.readString(); 
        if (!item.equals("-")) s.push(item);
        else if (!s.isEmpty()) StdOut.print(s.pop() + " ");
    }
    StdOut.println("(" + s.size() + " left on stack)");
}
```

通过上面的例子可以看到, 非泛型实现的 Stack 使用上非常局限. 故实现了一个泛型的定长 Stack.

### 1.4.2 数组的扩容

由于在 Java 或 C# 等语言中创建的数组是定长的, 进而造成如果使用定长数组来实现 Stack, 就必须在创建时指定大小, 这显然是非常死板的.

故在 push 或 pop 的实现时, 根据当前数组是否满, 或者当前容量未能超过数组最大容量的 1/4, 将数组进行大小进行调整:

```java
private void resize(int maxSize) {
    Item[] temp = (Item[]) new Object[max];
    for (int i = 0; i < N; i++)
        temp[i] = a[i];
    a = temp;
}
```

### 1.4.3 迭代器

使用迭代器的目的是让客户代码可以在不知道集合内部具体数据类型的情况下, 对集合进行遍历.

典型的客户代码如下所示, 使用 `foreach` 进行遍历:

```java
Stack<String> collection = new Stack<String>();
for (String s : collection) StdOut.println(s);
```

上述代码等价于获取到集合的 iterator 后再进行 while 操作:

```java
Iterator<String> i = collection.iterator(); 
while (i.hasNext()) {
    String s = i.next();
    StdOut.println(s);
}
```

可以看到, 迭代器的主要方法就两个: 

- `hasNext`

- `next`

实现了一个 C# 版本的逆序迭代器, 实现上说还是非常简单的.

### 1.4.4 链表

链表的定义可以使用递归描述, 它要么是空, 要么是一个节点, 这个节点包含数据域和指向链表节点的指针域.

链表插入和删除操作:

- 从头部添加/删除

- 从尾部添加/删除

链表的遍历操作: 跟随 next 指针一路遍历直至 next == null.

有了上述前提, 就可以实现以链式存储结构表示的栈逻辑结构了.

### 1.4.5 队列

由于队列是先入先出结构, 使用链表来表示非常合适. 

主要操作如下:

- enqueue: 从队尾入队

- dequeue: 从队头出队

一段典型的队列客户代码如下所示:

```java
// Create a queue and enqueue/dequeue strings
public static void main(String[] args) { 
    Queue<String> q = new Queue<String>();
    while (!StdIn.isEmpty()) {
        String item = StdIn.readString(); 
        if (!item.equals("-")) q.enqueue(item);
        else if (!q.isEmpty()) StdOut.print(q.dequeue() + " ");
    }
    StdOut.println("(" + q.size() + " left on queue)"); 
}
```

简单队列在实现的时候仍然采用单链表, 并记录队首, 队尾, 队列长度等信息.

### 1.4.6 队列和栈的实现: 基于单链表

1. 单链表的 TDD 实现: 头插完成. 准备尾插.

1. 基于单链表的队列/栈/bag实现: 采用 TDD.

1. 几种基本数据结构的迭代接口/迭代器实现: 在迭代器输出值的过程中, 需要遵循如下顺序:

- 队列 FIFO

- 栈: LIFO

- bag: LIFO

上述几种数据结构和它上面的操作必须熟练, 因为他们是后续学习的基础:

1. 在后续学习过程中, 需要基于上述基本数据结构来实现更高级的其他数据结构.
1. 在基本数据结构实现过程中, 可以认识到数据结构上面的算法是如何实现的, 并且是如何保证性能的.
1. 我们着眼点是在 ADT 上, 这些 ADT 支持针对集合的更为复杂的操作.

### 1.4.7 总结

当前我们可以使用两种**存储结构**来表示集合了:

- 数组: 支持随机存取, 但需要在初始化时指定空间大小.

- 链表: 支持快速插入删除, 但不支持随机存取.

其他的存储结构有待探索.

但逻辑结构目前还只学了一种: 线性结构, 不过后续还会接触到树和图. 关注的重点是在数据结构特性上, 另外就是数据结构的组合使用上.

复杂的数据结构可以通过简单的数据结构进行组合构成, 将关注点放到抽象接口上, 可以帮助减少数据结构在实现和理解上的复杂性.

另外在书中使用如下流程来介绍一个数据结构和在它上面实现的算法:

1. 定义 API
1. 实现客户代码(或单元测试 TDD)
1. 描述可以实现这个 API 的数据结构的 ADT.
1. 描述算法, 这些算法即 API 所需的方法实现描述.
1. 分析算法的性能特征(时间/空间).

至 1.4 算法分析. p172.

## 1.5 算法分析

在实现算法时, 主要关心的是算法的时间开销和内存开销, 即时间和空间两个方面的考虑.

在分析时, 使用数学分析方法来定义一个精确的模型, 根据实际的情况来修正这个模型, 

根据现实世界中的模型构建, 步骤可以描述为:

1. 观察自然界中的某个特征, 观察时通常使用一些精确的测量方法.

1. 通过这些观察, 生成一个假设模型.

1. 通过模型来语言这个特征未来的变化规律.

1. 通过更多的观察来验证假设, 并不断修正假设模型

1. 重复这样的过程, 直到假设模型的预测和现实数据吻合.

### 1.5.1 特征观察

使用如下例子程序来进行:

```cs
//  分析时, 主要测试这段代码的执行时间:
public static int Count(int[] a) {
    int N = a.Length;
    int cnt = 0;
    for (int i = 0; i < N; i++)
        for (int j = i + 1; j < N; j++)
            for (int k = j + 1; k < N; k++)
                if (a[i] + a[j] + a[k] == 0) cnt++;
    return cnt;
}

// 生成随机数组, 通过命令行参数获取输入的规模(有多少个数字)
public static int[] GetRandomArray(string[] args) {
    int count = int.Parse(args[0]);
    int[] a = new int[count];
    for (int i = 0; i < count; i++)
        a[i] = new Random().Next(-1000000, 1000000);
    return a;
}
```

## 实验数据分析

1. 问题规模:

    需要观察的是: 随问题规模增长, 运行时间是如何增长的?

例子程序已经实现(三个数相加), 至 P176 分析实验数据前.

## 本节小结

我们关注的算法都是经过了几十年的研究和发展的, 在未来也会继续发挥它们的重要作用. 本书的章节划分如下:

1. C1 Fundamentals: 介绍用于算法实现/分析/比较的基本原则和基本方法.

1. C2 Sorting: 深入介绍插入排序, 选择排序, 希尔排序, 快速排序, 归并排序, 堆排序. 另外介绍一些相关问题(优先级队列, 选择, 合并)的算法. (排序的另一个目的是为查找服务)

1. C3 Searching: 介绍有关查找的基础/高级方法, 包括二叉查找树, 平衡搜索树, 哈希.

1. C4 Graphs: 图是许多重要问题的主要模型. 这章介绍图的广度优先/深度优先搜索, 连通性问题, 最小生成树, 最短路径等问题.

1. C5 Strings: 字符串是现代计算机程序的重要数据类型. 字符串即字符序列, 本章介绍一些字符序列的处理算法, 包括字符序列的排序和查找, 子串搜索, 正则表达式匹配, 数据压缩算法.

1. C6 Context: 将本书介绍的方法应用到相关的上下文环境中, 例如科学计算, 运筹学, 计算理论. 我们进而去探索事件驱动的模拟, B树等高级话题.

算法和数据结构紧密结合, 还需要学习一些数据结构的性质特点. 且要有这样的概念: 一个算法可以使用任何语言在任何平台上都能实现的.